---
id: 135132
author: Colin Eberhardt
tags: 
categories: 
- Blog
layout: ceberhardt_post
---

<p>With the new Metro UI, Windows 8 has firmly embraced the tablet form-factor, with the interface tailored for touch and multi-touch interactions. Many of the Metro concepts familiar to Windows Phone 7 (WP7) developers are also present in Windows 8. Watching the vieos from the //build/ conference you can see how the team responsible for Win8 Metro have really thought about the tablet experience, with new concepts such as <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh465299(v=VS.85).aspx">cross-slide</a> and <a href="http://www.scottlogic.co.uk/blog/colin/2011/10/winrt-transitions-creating-fast-and-fluid-metro-uis/">transitions</a> being added to the familiar XAML environment.</p>
<p>One of the most intersting new concepts introduced at build was &#8216;semantic zoom&#8217;, where a pinch gesture, which is more usually assocaited with optical zoom, is used to switch between different view of the same data. Because a pinch is conceptually a zoom operation, this is most typically used for switching from a more detailed view to a summary, or top-level view. Interestingly, with WP7 we have already seen the semantic zoom concept (minus the pinch gesture). The <a href="http://www.scottlogic.co.uk/blog/colin/2011/01/a-windows-phone-7-jump-list-control/">jump list control</a> provides a mechanism for jumping from one location within a list to another, via jump-buttons. This solves the problem of navigating long lists using swipe gestures. However, semantic zoom does not have to be restricted to jump-list style scenarios, for more ideas see the <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh465319(v=VS.85).aspx#scroll_jump">Microsoft Guidelines for Semantic Zoom</a>.</p>
<p>I thought that a fun way to familiarise myself with semantic zoom would be to use it to create a WP7 style jump list experience in Win8 Metro, you can see a (very poorly filmed) video of my creation below &#8230;</p>
<p><iframe width="420" height="315" src="http://www.youtube.com/embed/dn4-fhLro8U" frameborder="0" allowfullscreen></iframe></p>
<p>The <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.controls.jumpviewer">JumpViewer</a> control provides semantic zoom functionality. This control allows you to specify two views, which would most typically be as follows:</p>
<ul>
<li><code>ContentView </code>- the detail view. </li>
<li><code>JumpView </code>- the top-level, or category view.</li>
</ul>
<p>However, you can provide any two views of your data, as long as there is some meaningful (or semantic!) relationship between the two.<br />Both views must implement <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.controls.ijumpviewerinfo">IJumpViewerInfo</a> (As an aside, WinRT makes much better use of interfaces than the .NET XAML UIs), which has methods that allows the <code>JumpViewer</code> to instruct a view to make a certain item visible. This allows the two views to colaborate in order to allow navigation. The <code>GridView </code>control, which is part of the WinRT framework, implements this interface, so is a suitable control to use for both views. </p>
<h2>The ContentView</h2>
<p>So let&#8217;s create a content view that renders a jump-list style control. You specify each of the view as follows:</p>
<div class="wp_syntax"><div class="code">{% highlight xml %}<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;JumpViewer</span> <span style="color: #000066;">x:Name</span>=<span style="color: #ff0000;">&quot;jumpViewer&quot;</span><span style="color: #000000; font-weight: bold;">&gt;</span></span>
  <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;JumpViewer.JumpView<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
    <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;GridView<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
      ...
    <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/GridView<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
  <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/JumpViewer.JumpView<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
  <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;JumpViewer.ContentView<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
    <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;GridView<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
       ...
    <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/GridView<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
  <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;JumpViewer.ContentView<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/JumpViewer<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>{% endhighlight %}
</div>
</div>
<p>The <code>JumpViewer </code>requires that you supply a <code>CollectionViewSource </code>to the <code>JumpView</code> in order to render the top-level view. Also, I have found that whereas the <code>ContentView </code>inherits the <code>JumpViewer</code> <code>DataContext</code>, making databinding possible, the <code>JumpView</code> does not. This results in a rather clumsy syntax for supplying data to this control:</p>
<div class="wp_syntax"><div class="code">{% highlight csharp %}var cvs <span style="color: #008000;">=</span> <span style="color: #008000;">new</span> CollectionViewSource<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
cvs<span style="color: #008000;">.</span><span style="color: #0000FF;">Source</span> <span style="color: #008000;">=</span> source<span style="color: #008000;">;</span>
jumpViewer<span style="color: #008000;">.</span><span style="color: #0000FF;">DataContext</span> <span style="color: #008000;">=</span> cvs<span style="color: #008000;">;</span>
<span style="color: #008000;">&#40;</span>jumpViewer<span style="color: #008000;">.</span><span style="color: #0000FF;">JumpView</span> <span style="color: #0600FF; font-weight: bold;">as</span> ListViewBase<span style="color: #008000;">&#41;</span><span style="color: #008000;">.</span><span style="color: #0000FF;">ItemsSource</span> <span style="color: #008000;">=</span> cvs<span style="color: #008000;">.</span><span style="color: #0000FF;">View</span><span style="color: #008000;">.</span><span style="color: #0000FF;">CollectionGroups</span><span style="color: #008000;">;</span>{% endhighlight %}
</div>
</div>
<p>It would be possible to wrap up the above code in an attached behaviour, to allow binding without code-behind, but it is not really worth the effort. I am sure this will be tidied up in future versions!</p>
<p>The <code>ContentView</code> is a <code>GridView</code> which by default scrolls its content horizontally. For my jump-list I wanted to scroll vertically, this can be achieved by setting the following attached properties:</p>
<pre lang=="xml">
<GridView ItemsSource="{Binding}"
            ScrollViewer.HorizontalScrollBarVisibility="Disabled"
            ScrollViewer.VerticalScrollBarVisibility="Auto"
            ScrollViewer.HorizontalScrollMode="Disabled"
            ScrollViewer.VerticalScrollMode="Enabled">
